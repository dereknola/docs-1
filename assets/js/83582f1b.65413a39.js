"use strict";(self.webpackChunkk_3_s_docs=self.webpackChunkk_3_s_docs||[]).push([[966],{3905:(e,t,r)=>{r.d(t,{Zo:()=>c,kt:()=>p});var n=r(7294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function s(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?s(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):s(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function o(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},s=Object.keys(e);for(n=0;n<s.length;n++)r=s[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)r=s[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var l=n.createContext({}),u=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},c=function(e){var t=u(e.components);return n.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,s=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),h=u(r),p=a,m=h["".concat(l,".").concat(p)]||h[p]||d[p]||s;return r?n.createElement(m,i(i({ref:t},c),{},{components:r})):n.createElement(m,i({ref:t},c))}));function p(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var s=r.length,i=new Array(s);i[0]=h;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:a,i[1]=o;for(var u=2;u<s;u++)i[u]=r[u];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}h.displayName="MDXCreateElement"},5162:(e,t,r)=>{r.d(t,{Z:()=>i});var n=r(7294),a=r(6010);const s="tabItem_Ymn6";function i(e){let{children:t,hidden:r,className:i}=e;return n.createElement("div",{role:"tabpanel",className:(0,a.Z)(s,i),hidden:r},t)}},4866:(e,t,r)=>{r.d(t,{Z:()=>T});var n=r(3117),a=r(7294),s=r(6010),i=r(2466),o=r(6775),l=r(1980),u=r(7392),c=r(12);function d(e){return function(e){return a.Children.map(e,(e=>{if((0,a.isValidElement)(e)&&"value"in e.props)return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))}(e).map((e=>{let{props:{value:t,label:r,attributes:n,default:a}}=e;return{value:t,label:r,attributes:n,default:a}}))}function h(e){const{values:t,children:r}=e;return(0,a.useMemo)((()=>{const e=t??d(r);return function(e){const t=(0,u.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,r])}function p(e){let{value:t,tabValues:r}=e;return r.some((e=>e.value===t))}function m(e){let{queryString:t=!1,groupId:r}=e;const n=(0,o.k6)(),s=function(e){let{queryString:t=!1,groupId:r}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!r)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return r??null}({queryString:t,groupId:r});return[(0,l._X)(s),(0,a.useCallback)((e=>{if(!s)return;const t=new URLSearchParams(n.location.search);t.set(s,e),n.replace({...n.location,search:t.toString()})}),[s,n])]}function g(e){const{defaultValue:t,queryString:r=!1,groupId:n}=e,s=h(e),[i,o]=(0,a.useState)((()=>function(e){let{defaultValue:t,tabValues:r}=e;if(0===r.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!p({value:t,tabValues:r}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${r.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const n=r.find((e=>e.default))??r[0];if(!n)throw new Error("Unexpected error: 0 tabValues");return n.value}({defaultValue:t,tabValues:s}))),[l,u]=m({queryString:r,groupId:n}),[d,g]=function(e){let{groupId:t}=e;const r=function(e){return e?`docusaurus.tab.${e}`:null}(t),[n,s]=(0,c.Nk)(r);return[n,(0,a.useCallback)((e=>{r&&s.set(e)}),[r,s])]}({groupId:n}),b=(()=>{const e=l??d;return p({value:e,tabValues:s})?e:null})();(0,a.useLayoutEffect)((()=>{b&&o(b)}),[b]);return{selectedValue:i,selectValue:(0,a.useCallback)((e=>{if(!p({value:e,tabValues:s}))throw new Error(`Can't select invalid tab value=${e}`);o(e),u(e),g(e)}),[u,g,s]),tabValues:s}}var b=r(2389);const f="tabList__CuJ",v="tabItem_LNqP";function k(e){let{className:t,block:r,selectedValue:o,selectValue:l,tabValues:u}=e;const c=[],{blockElementScrollPositionUntilNextRender:d}=(0,i.o5)(),h=e=>{const t=e.currentTarget,r=c.indexOf(t),n=u[r].value;n!==o&&(d(t),l(n))},p=e=>{let t=null;switch(e.key){case"Enter":h(e);break;case"ArrowRight":{const r=c.indexOf(e.currentTarget)+1;t=c[r]??c[0];break}case"ArrowLeft":{const r=c.indexOf(e.currentTarget)-1;t=c[r]??c[c.length-1];break}}t?.focus()};return a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.Z)("tabs",{"tabs--block":r},t)},u.map((e=>{let{value:t,label:r,attributes:i}=e;return a.createElement("li",(0,n.Z)({role:"tab",tabIndex:o===t?0:-1,"aria-selected":o===t,key:t,ref:e=>c.push(e),onKeyDown:p,onClick:h},i,{className:(0,s.Z)("tabs__item",v,i?.className,{"tabs__item--active":o===t})}),r??t)})))}function y(e){let{lazy:t,children:r,selectedValue:n}=e;if(r=Array.isArray(r)?r:[r],t){const e=r.find((e=>e.props.value===n));return e?(0,a.cloneElement)(e,{className:"margin-top--md"}):null}return a.createElement("div",{className:"margin-top--md"},r.map(((e,t)=>(0,a.cloneElement)(e,{key:t,hidden:e.props.value!==n}))))}function w(e){const t=g(e);return a.createElement("div",{className:(0,s.Z)("tabs-container",f)},a.createElement(k,(0,n.Z)({},e,t)),a.createElement(y,(0,n.Z)({},e,t)))}function T(e){const t=(0,b.Z)();return a.createElement(w,(0,n.Z)({key:String(t)},e))}},9001:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>h,contentTitle:()=>c,default:()=>g,frontMatter:()=>u,metadata:()=>d,toc:()=>p});var n=r(3117),a=(r(7294),r(3905)),s=r(941),i=r(4996),o=r(5162),l=r(4866);const u={title:"Architecture",weight:1},c=void 0,d={unversionedId:"architecture/architecture",id:"architecture/architecture",title:"Architecture",description:"This page describes the architecture of a high-availability K3s server cluster and how it differs from a single-node server cluster.",source:"@site/docs/architecture/architecture.md",sourceDirName:"architecture",slug:"/architecture/",permalink:"/docs-k3s/architecture/",draft:!1,editUrl:"https://github.com/k3s-io/docs/edit/main/docs/architecture/architecture.md",tags:[],version:"current",lastUpdatedAt:1682707376,formattedLastUpdatedAt:"Apr 28, 2023",frontMatter:{title:"Architecture",weight:1},sidebar:"mySidebar",previous:{title:"K3s - Lightweight Kubernetes",permalink:"/docs-k3s/"},next:{title:"Quick-Start Guide",permalink:"/docs-k3s/quick-start/"}},h={},p=[{value:"Single-server Setup with an Embedded DB",id:"single-server-setup-with-an-embedded-db",level:3},{value:"High-Availability K3s",id:"high-availability-k3s",level:3},{value:"Fixed Registration Address for Agent Nodes",id:"fixed-registration-address-for-agent-nodes",level:3},{value:"How Agent Node Registration Works",id:"how-agent-node-registration-works",level:3}],m={toc:p};function g(e){let{components:t,...u}=e;return(0,a.kt)("wrapper",(0,n.Z)({},m,u,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"This page describes the architecture of a high-availability K3s server cluster and how it differs from a single-node server cluster."),(0,a.kt)("p",null,"It also describes how agent nodes are registered with K3s servers."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"A server node is defined as a host running the ",(0,a.kt)("inlineCode",{parentName:"li"},"k3s server")," command, with control-plane and datastore components managed by K3s."),(0,a.kt)("li",{parentName:"ul"},"An agent node is defined as a host running the ",(0,a.kt)("inlineCode",{parentName:"li"},"k3s agent")," command, without any datastore or control-plane components."),(0,a.kt)("li",{parentName:"ul"},"Both servers and agents run the kubelet, container runtime, and CNI. See the ",(0,a.kt)("a",{parentName:"li",href:"/docs-k3s/advanced/#running-agentless-servers-experimental"},"Advanced Options")," documentation for more information on running agentless servers.")),(0,a.kt)("p",null,(0,a.kt)("img",{src:r(3923).Z,width:"1562",height:"898"})),(0,a.kt)("h3",{id:"single-server-setup-with-an-embedded-db"},"Single-server Setup with an Embedded DB"),(0,a.kt)("p",null,"The following diagram shows an example of a cluster that has a single-node K3s server with an embedded SQLite database."),(0,a.kt)("p",null,"In this configuration, each agent node is registered to the same server node. A K3s user can manipulate Kubernetes resources by calling the K3s API on the server node."),(0,a.kt)(s.Z,{alt:"K3s Architecture with a Single Server",sources:{light:(0,i.Z)("/img/k3s-architecture-single-server.svg"),dark:(0,i.Z)("/img/k3s-architecture-single-server-dark.svg")},mdxType:"ThemedImage"}),(0,a.kt)("h3",{id:"high-availability-k3s"},"High-Availability K3s"),(0,a.kt)("p",null,"Single server clusters can meet a variety of use cases, but for environments where uptime of the Kubernetes control plane is critical, you can run K3s in an HA configuration. An HA K3s cluster comprises:"),(0,a.kt)(l.Z,{mdxType:"Tabs"},(0,a.kt)(o.Z,{value:"Embedded DB",mdxType:"TabItem"},(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Three or more ",(0,a.kt)("strong",{parentName:"li"},"server nodes")," that will serve the Kubernetes API and run other control plane services"),(0,a.kt)("li",{parentName:"ul"},"An ",(0,a.kt)("strong",{parentName:"li"},"embedded etcd datastore")," (as opposed to the embedded SQLite datastore used in single-server setups)")),(0,a.kt)(s.Z,{alt:"K3s Architecture with High-availability Servers",sources:{light:(0,i.Z)("/img/k3s-architecture-ha-embedded.svg"),dark:(0,i.Z)("/img/k3s-architecture-ha-embedded-dark.svg")},mdxType:"ThemedImage"})),(0,a.kt)(o.Z,{value:"External DB",mdxType:"TabItem"},(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Two or more ",(0,a.kt)("strong",{parentName:"li"},"server nodes")," that will serve the Kubernetes API and run other control plane services"),(0,a.kt)("li",{parentName:"ul"},"An ",(0,a.kt)("strong",{parentName:"li"},"external datastore")," (such as MySQL, PostgreSQL, or etcd)")),(0,a.kt)(s.Z,{alt:"K3s Architecture with High-availability Servers and an External DB",sources:{light:(0,i.Z)("/img/k3s-architecture-ha-external.svg"),dark:(0,i.Z)("/img/k3s-architecture-ha-external-dark.svg")},mdxType:"ThemedImage"}))),(0,a.kt)("h3",{id:"fixed-registration-address-for-agent-nodes"},"Fixed Registration Address for Agent Nodes"),(0,a.kt)("p",null,"In the high-availability server configuration, each node can also register with the Kubernetes API by using a fixed registration address, as shown in the diagram below."),(0,a.kt)("p",null,"After registration, the agent nodes establish a connection directly to one of the server nodes."),(0,a.kt)(s.Z,{alt:"Agent Registration HA",sources:{light:(0,i.Z)("/img/k3s-production-setup.svg"),dark:(0,i.Z)("/img/k3s-production-setup-dark.svg")},mdxType:"ThemedImage"}),(0,a.kt)("h3",{id:"how-agent-node-registration-works"},"How Agent Node Registration Works"),(0,a.kt)("p",null,"Agent nodes are registered with a websocket connection initiated by the ",(0,a.kt)("inlineCode",{parentName:"p"},"k3s agent")," process, and the connection is maintained by a client-side load balancer running as part of the agent process. Initially, the agent connects to the supervisor (and kube-apiserver) via the local load-balancer on port 6443. The load-balancer maintains a list of available endpoints to connect to. The default (and initially only) endpoint is seeded by the hostname from the ",(0,a.kt)("inlineCode",{parentName:"p"},"--server")," address. Once it connects to the cluster, the agent retrieves a list of kube-apiserver addresses from the Kubernetes service endpoint list in the default namespace. Those endpoints are added to the load balancer, which then maintains stable connections to all servers in the cluster, providing a connection to the kube-apiserver that tolerates outages of individual servers."),(0,a.kt)("p",null,"Agents will register with the server using the node cluster secret along with a randomly generated password for the node, stored at ",(0,a.kt)("inlineCode",{parentName:"p"},"/etc/rancher/node/password"),". The server will store the passwords for individual nodes as Kubernetes secrets, and any subsequent attempts must use the same password. Node password secrets are stored in the ",(0,a.kt)("inlineCode",{parentName:"p"},"kube-system")," namespace with names using the template ",(0,a.kt)("inlineCode",{parentName:"p"},"<host>.node-password.k3s"),". This is done to protect the integrity of node IDs."),(0,a.kt)("p",null,"If the ",(0,a.kt)("inlineCode",{parentName:"p"},"/etc/rancher/node")," directory of an agent is removed, or you wish to rejoin a node using an existing name, the node should be deleted from the cluster. This will clean up both the old node entry, and the node password secret, and allow the node to (re)join the cluster."),(0,a.kt)("p",null,"If you frequently reuse hostnames, but are unable to remove the node password secrets, a unique node ID can be automatically appended to the hostname by launching K3s servers or agents using the ",(0,a.kt)("inlineCode",{parentName:"p"},"--with-node-id")," flag. When enabled, the node ID is also stored in ",(0,a.kt)("inlineCode",{parentName:"p"},"/etc/rancher/node/"),"."))}g.isMDXComponent=!0},3923:(e,t,r)=>{r.d(t,{Z:()=>n});const n=r.p+"assets/images/how-it-works-k3s-revised-9c025ef482404bca2e53a89a0ba7a3c5.svg"}}]);